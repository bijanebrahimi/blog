<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Routines Excluded - Unix</title><link href="http://bijanebrahimi.github.io/blog/" rel="alternate"></link><link href="http://bijanebrahimi.github.io/blog/feeds/unix.atom.xml" rel="self"></link><id>http://bijanebrahimi.github.io/blog/</id><updated>2017-04-02T22:20:00+04:30</updated><entry><title>Looking at The Evolution of the Unix Time-sharing System</title><link href="http://bijanebrahimi.github.io/blog/looking-at-the-evolution-of-the-unix-time-sharing-system.html" rel="alternate"></link><published>2017-04-02T22:20:00+04:30</published><updated>2017-04-02T22:20:00+04:30</updated><author><name>Bijan</name></author><id>tag:bijanebrahimi.github.io,2017-04-02:/blog/looking-at-the-evolution-of-the-unix-time-sharing-system.html</id><summary type="html">&lt;h1&gt;Evolution of the Unix Time-Sharing System&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="http://www.read.seas.harvard.edu/~kohler/class/aosref/ritchie84evolution.pdf"&gt;The Evolution of the Unix Time-Sharing System&lt;/a&gt;&lt;/strong&gt; is an article by &lt;strong&gt;Denis Ritchie&lt;/strong&gt;
describing the early history of the &lt;strong&gt;UNIX&lt;/strong&gt; operating system, including creation and
design of some of (almost) unique features of the the operating system such as it's filesystem,
process controlls, I â€¦&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Evolution of the Unix Time-Sharing System&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="http://www.read.seas.harvard.edu/~kohler/class/aosref/ritchie84evolution.pdf"&gt;The Evolution of the Unix Time-Sharing System&lt;/a&gt;&lt;/strong&gt; is an article by &lt;strong&gt;Denis Ritchie&lt;/strong&gt;
describing the early history of the &lt;strong&gt;UNIX&lt;/strong&gt; operating system, including creation and
design of some of (almost) unique features of the the operating system such as it's filesystem,
process controlls, I/O redirection and a few more. Surprisingly, almost 50 years later,
we're experiencing almost the same features (ofc with many more new cool stuff) but it's
fascinating to see how much of the design still is within the current Unix-based operating
systems such as &lt;strong&gt;linux&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;While I'm highly recommending reading the original article, I find it fun to track some
of mysteries I was facing at work lately:&lt;/p&gt;
&lt;h1&gt;Zombie Town&lt;/h1&gt;
&lt;p&gt;With adaption of new &lt;code&gt;fork&lt;/code&gt; system call, forking (&lt;code&gt;fork&lt;/code&gt;) a new process and executing (&lt;code&gt;exec&lt;/code&gt;)
the child command has become somewhat of an standard. Investitaging the actual process, reminded
me of chasing a &lt;strong&gt;BUG&lt;/strong&gt; which mysteriousy brought down some of our &lt;strong&gt;BSD&lt;/strong&gt; machines at work.
It turned out, somehow one f our daemons running as root is producing &lt;strong&gt;zombie&lt;/strong&gt; processes without
attending them. Although a zombie process is merely just a few structs in kernel memory, leaving
them unattended may lead to unexpected behaviors. In our case, the zombie processes caused the
&lt;code&gt;root&lt;/code&gt; user to exceed it's maximum running processes limit (&lt;code&gt;kern.maxprocperuid&lt;/code&gt;) causing
the system to stop working. So what was the issue?&lt;/p&gt;
&lt;p&gt;Ever wondered what actually happens between forking a new process, clonning the current process
to an almost exact copy of it's own and actually executing the child command? and what actually
can go wrong between these two calls? Well, the process mentioned above is the same routine the
&lt;a href="https://github.com/freebsd/freebsd/blob/master/lib/libc/gen/popen.c"&gt;popen&lt;/a&gt; function does on &lt;a href="https://github.com/freebsd/freebsd/tree/master/lib/libc"&gt;FreeBSD libc&lt;/a&gt; library. It forks the process, closes all of it's parent
open file descriptors and executing the child command. Since before calling &lt;code&gt;_execv&lt;/code&gt; command, we're
still running the same code as parent, if the code crashes, it crashes like the parent process
crashed, not the child command.&lt;/p&gt;
&lt;p&gt;Still I'm not quiet sure why the code crashes in the child process calling &lt;code&gt;_close&lt;/code&gt; before
executing the &lt;code&gt;_execv&lt;/code&gt; system call but a quick fix was to install a &lt;code&gt;SIGCHLD&lt;/code&gt; handler, closing
the child zombie process.&lt;/p&gt;
&lt;h1&gt;Know Thy Builtins&lt;/h1&gt;
&lt;p&gt;As ritchie continues, when addapting the new multiprocessing capability with design of the
new &lt;code&gt;fork&lt;/code&gt; system call, they discovered that the &lt;code&gt;chdir&lt;/code&gt; command stopeed working. Investigation
through the process, they relasized now that when shell forks the &lt;code&gt;chdir&lt;/code&gt; procss, it executed
fine and actually did change the current working directory but since it's not changing it's 
parent process (the running shell), after termination, the shell is still in the same directory
as before.&lt;/p&gt;
&lt;p&gt;I actually found a similar &lt;strong&gt;BUG&lt;/strong&gt; in one of our programs a few month before, when a fellow
programmer modified a shell script adding pull path names to every commands including the
&lt;code&gt;cd&lt;/code&gt; command. since &lt;code&gt;/bin/cd&lt;/code&gt; is a binary and can't effect the parent shell process (the same
reason above), the script was end up doing it's stuff in a wrong directory. so it's
&lt;strong&gt;Important&lt;/strong&gt; to notice that &lt;code&gt;cd&lt;/code&gt; command is actually a built-in shell command, capable of
changing current shell working directory:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;type&lt;/span&gt; &lt;span class="nb"&gt;cd&lt;/span&gt;
&lt;span class="nb"&gt;cd&lt;/span&gt; is a shell &lt;span class="nb"&gt;builtin&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;So, what's the use of the &lt;code&gt;cd&lt;/code&gt; binary command? I'm not quiet sure but one &lt;a href="https://unix.stackexchange.com/a/50060"&gt;example&lt;/a&gt;  I find
was to check which directories we have access to visit:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;find . -type d -exec /bin/cd &lt;span class="o"&gt;{}&lt;/span&gt; &lt;span class="se"&gt;\;&lt;/span&gt; -print
&lt;/pre&gt;&lt;/div&gt;</content><category term="unix"></category><category term="design"></category><category term="ritchie"></category><category term="thompson"></category><category term="linux"></category><category term="article"></category></entry></feed>